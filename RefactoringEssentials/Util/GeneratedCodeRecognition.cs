using System;
using System.IO;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using System.Threading;
using System.Linq;
using Microsoft.CodeAnalysis.CSharp;
using System.Collections.Immutable;

namespace RefactoringEssentials
{
    public static class GeneratedCodeRecognition
    {
        public static bool IsFromGeneratedCode(this SemanticModel semanticModel, CancellationToken cancellationToken)
        {
            return IsFileNameForGeneratedCode(semanticModel.SyntaxTree.FilePath) || ContainsAutogeneratedComment(semanticModel.SyntaxTree, cancellationToken);
        }

        public static bool IsFromGeneratedCode(this SyntaxNodeAnalysisContext context)
        {
            return IsFromGeneratedCode(context.SemanticModel, context.CancellationToken);
        }

        public static bool IsFromGeneratedCode(this SemanticModelAnalysisContext context)
        {
            return IsFromGeneratedCode(context.SemanticModel, context.CancellationToken);
        }

        static readonly string[] generatedCodeSuffixes = {
            "AssemblyInfo",
            ".designer",
            ".generated",
            ".g",
            ".g.i",
            ".AssemblyAttributes"
        };

        public unsafe static bool IsFileNameForGeneratedCode(string fileName)
        {
            if (fileName.StartsWith("TemporaryGeneratedFile_", StringComparison.OrdinalIgnoreCase))
            {
                return true;
            }

            int idx = fileName.LastIndexOf ('.');
            if (idx < 0)
                return false;
            fixed (char* beginPtr = fileName)
            {
                char *endPtr = beginPtr + idx;

                for (int i = 0; i < generatedCodeSuffixes.Length; i++)
                {
                    string str = generatedCodeSuffixes[i];
                    int p = idx - str.Length;
                    if (p < 0)
                        continue;
                    char* curPtr = beginPtr + p;
                    fixed (char* patternPtr = str)
                    {
                        char* curPatternPtr = patternPtr;
                        while (curPtr != endPtr)
                        {
                            if (char.ToUpperInvariant (*curPtr) != char.ToUpperInvariant (*curPatternPtr))
                            {
                                break;
                            }
                            curPtr++;
                            curPatternPtr++;
                        }
                        if (curPtr == endPtr)
                        {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        static WeakReference<ImmutableDictionary<SyntaxTree, bool>> cache = new WeakReference<ImmutableDictionary<SyntaxTree, bool>> (ImmutableDictionary<SyntaxTree, bool>.Empty);

        static bool ContainsAutogeneratedComment(SyntaxTree tree, CancellationToken cancellationToken = default(CancellationToken))
        {
            ImmutableDictionary<SyntaxTree, bool> table;

            if (cache.TryGetTarget(out table))
            {
                if (table.ContainsKey(tree))
                    return table[tree];
            }

            table = ImmutableDictionary<SyntaxTree, bool>.Empty;

            var root = tree.GetRoot(cancellationToken);
            if (root == null)
                return false;
            var firstToken = root.GetFirstToken();
            if (!firstToken.HasLeadingTrivia)
            {
                cache.SetTarget(table.Add(tree, false));
                return false;
            }

            foreach (var trivia in firstToken.LeadingTrivia.Where(t => t.IsKind(SyntaxKind.SingleLineCommentTrivia)).Take(2))
            {
                var str = trivia.ToString();
                if (str == "// This file has been generated by the GUI designer. Do not modify." ||
                    str == "// <auto-generated>" || str == "// <autogenerated>")
                {
                    cache.SetTarget(table.Add(tree, true));
                    return true;
                }
            }
            cache.SetTarget(table.Add(tree, false));
            return false;
        }
    }
}