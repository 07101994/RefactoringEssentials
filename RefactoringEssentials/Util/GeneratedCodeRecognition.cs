using System;
using System.IO;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using System.Threading;
using System.Linq;
using Microsoft.CodeAnalysis.CSharp;
using System.Collections.Immutable;

namespace RefactoringEssentials
{
    static class GeneratedCodeRecognition
    {
        public static bool IsFromGeneratedCode(this SemanticModel semanticModel, CancellationToken cancellationToken)
        {
            return IsFileNameForGeneratedCode(semanticModel.SyntaxTree.FilePath) || ContainsAutogeneratedComment(semanticModel.SyntaxTree, cancellationToken);
        }

        public static bool IsFromGeneratedCode(this SyntaxNodeAnalysisContext context)
        {
            return IsFromGeneratedCode(context.SemanticModel, context.CancellationToken);
        }

        public static bool IsFromGeneratedCode(this SemanticModelAnalysisContext context)
        {
            return IsFromGeneratedCode(context.SemanticModel, context.CancellationToken);
        }

        public static bool IsFileNameForGeneratedCode(string fileName)
        {
            if (fileName.StartsWith("TemporaryGeneratedFile_", StringComparison.OrdinalIgnoreCase))
            {
                return true;
            }

            string extension = Path.GetExtension(fileName);
            if (extension != string.Empty)
            {
                fileName = Path.GetFileNameWithoutExtension(fileName);

                if (fileName.EndsWith("AssemblyInfo", StringComparison.OrdinalIgnoreCase) ||
                    fileName.EndsWith(".designer", StringComparison.OrdinalIgnoreCase) ||
                    fileName.EndsWith(".generated", StringComparison.OrdinalIgnoreCase) ||
                    fileName.EndsWith(".g", StringComparison.OrdinalIgnoreCase) ||
                    fileName.EndsWith(".g.i", StringComparison.OrdinalIgnoreCase) ||
                    fileName.EndsWith(".AssemblyAttributes", StringComparison.OrdinalIgnoreCase))
                {
                    return true;
                }
            }

            return false;
        }

        static WeakReference<ImmutableDictionary<SyntaxTree, bool>> cache = new WeakReference<ImmutableDictionary<SyntaxTree, bool>> (ImmutableDictionary<SyntaxTree, bool>.Empty);

        static bool ContainsAutogeneratedComment(SyntaxTree tree, CancellationToken cancellationToken = default(CancellationToken))
        {
            ImmutableDictionary<SyntaxTree, bool> table;

            if (cache.TryGetTarget(out table))
            {
                if (table.ContainsKey(tree))
                    return table[tree];
            }

            table = ImmutableDictionary<SyntaxTree, bool>.Empty;

            var root = tree.GetRoot(cancellationToken);
            if (root == null)
                return false;
            var firstToken = root.GetFirstToken();
            if (!firstToken.HasLeadingTrivia)
            {
                cache.SetTarget(table.Add(tree, false));
                return false;
            }

            foreach (var trivia in firstToken.LeadingTrivia.Where(t => t.IsKind(SyntaxKind.SingleLineCommentTrivia)).Take(2))
            {
                var str = trivia.ToString();
                if (str == "// This file has been generated by the GUI designer. Do not modify." ||
                    str == "// <auto-generated>" || str == "// <autogenerated>")
                {
                    cache.SetTarget(table.Add(tree, true));
                    return true;
                }
            }
            cache.SetTarget(table.Add(tree, false));
            return false;
        }
    }
}